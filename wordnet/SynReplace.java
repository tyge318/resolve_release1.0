// WordNet Synonym Replacing Examplepackage wordnet;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.File;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.io.InputStreamReader;import java.text.BreakIterator;import java.util.*;import org.codehaus.jackson.JsonProcessingException;import edu.stanford.nlp.parser.lexparser.LexicalizedParser;import edu.stanford.nlp.tagger.maxent.MaxentTagger;import net.didion.jwnl.*;import net.didion.jwnl.data.*;import net.didion.jwnl.data.list.PointerTargetNode;import net.didion.jwnl.data.list.PointerTargetNodeList;import net.didion.jwnl.data.relationship.*;import net.didion.jwnl.dictionary.Dictionary;public class SynReplace {	    public static void main(String[] args) throws JWNLException, JsonProcessingException, IOException, ClassNotFoundException {        // Initialize the database        // You must configure the properties file to point to your dictionary files        WordNetHelper.initialize("file_properties.xml");        LexicalizedParser lp = LexicalizedParser.loadModel("edu/stanford/nlp/models/lexparser/englishPCFG.ser.gz");     //        getEmoWordExtendList();            //        outputAllSynCandidates("exp303" + File.separator);//        outputAllSynCandidatesNew("temp" + File.separator, "learningExp" + File.separator);//        executeSynReplace("all240Articles" + File.separator, lp);        //        getAvailableSynList("all240Articles" + File.separator, "supportedSyns.txt");                /*        String[] settings = {"emoPatternlst_maxMarkovCS_L1L2_0107_Size369_noICF.txt",        					 "emoPatternlst_donothing_Size369.txt",         					 "emoPatternlst_maxMarkovCS_L1L2_0107_Size369.txt",         				 	 "emoPatternlst_noMarkovCS_L1_0107_Size369.txt",         				 	 "emoPatternlst_noMarkovCS_L1L2_0107_Size369.txt",        					 "emoPatternlst_IDF_Size369.txt",      					         					 "emoPatternlst_ICFonly_Size369.txt",        					 "emoPatternlst_L3_Size369.txt",        					 "emoPatternlst_L3+ICF_Size369.txt",        					 "emoPatternlst_L3+modICF_Size369.txt",        					 "emoPatternlst_L1only_add1_Size369.txt",        					 "emoPatternlst_L2only_ICF_Size369.txt",        					 "emoPatternlst_L1_ICF_0201.txt"        					 ,"mergedEmoPatternlist0219.txt"//        					 ,"emoPatternlst_L1_ICF_0224.txt"        					};        *///        String[] settings = {"0219best_merged_clear_v2.txt",//        					 "emoPatternlst_L1_ICF_0506_isp.txt",//        					 "emoPatternlst_L1_ICF_0508_esp.txt",//        					 "emoPatternlst_IDF_0219best_merged.txt"//        					};        String[] settings = {"emoPatternlst_L1_ICF_training_NE0707_isp.txt",				 "mergedEmoPatternlist0219.txt"				};//        String[] settings = {"emoPatternlst_L1_CTPonly_0219best_merged.txt",//        						"emoPatternlst_L1_DFonly_training_NE0707_isp.txt"//				};//        String[] PeFile = {"emoPatternlst_L1_CTPonly_0219best_merged_pe.txt",//        		"emoPatternlst_L1_DFonly_training_NE0707_isp_pe.txt"//				//        		};//        //       //        debugMode(lp, settings, true);                for(int i=1; i<2; i++) {        	//																			doRex, usePPL, useE, useN//        	executeSynReplaceSpecify("all240_mod" + File.separator, lp, settings[i], false, false);        	executeSynReplaceSpecifyPrepareTest("NewExp80Writing" + File.separator, lp, settings[i], false, false);//        	executeSynReplaceSpecify("33post-test" + File.separator, lp, settings[i], false, false);//        	executeSynReplaceSpecify_reForm("all240_mod" + File.separator, lp, settings[i], PeFile[i], false, false);//        	executeSynReplaceSpecify_weight("all240_mod" + File.separator, lp, settings[i], "wordpool.txt", false, false);//        	executeSynReplaceSpecify_N_E("all240Articles" + File.separator, lp, settings[i], false, false, true, true);																						//        	executeSynReplaceSpecify_N_E_add_opp("all240_mod" + File.separator, lp, settings[i], false, false, true, true);//        	executeSynReplaceSpecify_N_E_add("all240_test" + File.separator, lp, settings[i], false, false, true, true);//        	executeSynReplaceSpecify("testtt" + File.separator, lp, settings[i], false, false);//        	executeSynReplaceSpecify("all240Articles" + File.separator, lp, settings[i], true, false);//        	executeSynReplaceSpecifyWord("all240Articles" + File.separator, lp, settings[i], false, false);//        	executeSynReplaceSpecifyDice("all240Articles" + File.separator, lp, settings[i], false, false);//        	executeSynReplaceSpecifyPMI("all240Articles" + File.separator, lp, settings[i], false, false);        }//        executeSynReplaceSpecify("all240Articles" + File.separator, lp, settings[4], false, false);        //        executeSynReplaceSpecifyTFIDF("all240Articles" + File.separator, lp, settings[2], false, false);    }        public static void outputThesaurusResult(String inputDir) throws IOException, JWNLException, ClassNotFoundException{    	int amount = 5;    	final File folder = new File(inputDir);		ArrayList<String> allInputFileList = PatternStats.listFilesForFolder(folder);		ArrayList<String> inputTxtFileList = getInputTxtFileList(allInputFileList);		Iterator<String> iterator = inputTxtFileList.iterator();		BufferedReader br;		BufferedWriter bw, bw2;		bw = new BufferedWriter(new FileWriter("33Output_Thesaurus0320.txt"));		bw2 = new BufferedWriter(new FileWriter("33ProcessOrder.txt"));		while( iterator.hasNext()) {			String currentFile = iterator.next();			if( !currentFile.contains(".txt")) continue;						bw2.write(currentFile.replace(".txt", "") + "\n");			br = new BufferedReader(new FileReader(inputDir + currentFile));	        //read user's input from file.//	        System.out.println("Input file path: " + args[0] + "\n");	        String test = "";			String line;			while ((line = br.readLine()) != null) {					test += (line + "\n");			}			br.close();	//	        System.out.println("Content of the input file:\n" + test );	        	        //extract the starred emotion word	        String targetWord = extractTargetWord(test);	        System.out.println("Target Emotion Word is: " + targetWord + "\n");	        String targetWordPOS = findTargetWordPOS(test, targetWord);	        test = test.replace("*", "");	        	        //look up the word on wordnet affect, find synsets	        String tempSynSetStr = getSynsetStr(targetWord, targetWordPOS);	        tempSynSetStr = mergeSynStr( tempSynSetStr, VocabularyDotCom.getSynonyms(targetWord));	        String synSetStr = (tempSynSetStr.contains(" "+targetWord+" ")) ? tempSynSetStr: (targetWord + " " + tempSynSetStr);	        synSetStr.replaceAll("\\s+", " ");	        	        ArrayList<String> syns = new ArrayList(Arrays.asList(synSetStr.split(" ")));	        Collections.sort(syns);	        for(int i=0; i<5; i++) {	        	if( i >= syns.size())	break;	        	bw.write(syns.get(i) + "\t" + (6-i) + "\n");	        }	        bw.write("-\t-\n");	        bw.flush();		}		bw2.close();		bw.close();    }            public static void outputAllSynCandidatesNew(String inputDir, String originalDir) throws IOException, JWNLException {    	TreeMap<String, String> wordMap = new TreeMap<String, String>();    	File folder = new File(originalDir);    	ArrayList<String> allInputFileList = getInputTxtFileList(PatternStats.listFilesForFolder(folder));		Iterator<String> iterator = allInputFileList.iterator();		BufferedReader br;		while( iterator.hasNext()) {			String currentFile = iterator.next();			if( !currentFile.contains(".txt")) continue;			br = new BufferedReader(new FileReader(originalDir + currentFile));			String key = currentFile.split("_")[0];			String test = "";			String line;			while ((line = br.readLine()) != null) {					test += (line + "\n");			}			br.close();				String targetWord = extractTargetWord(test);			if( !wordMap.containsKey(key))				wordMap.put(key, targetWord);		}    	    	folder = new File(inputDir );    	HashMap<String, String> emotionHash = getEmotionHash("emoWords.txt");		allInputFileList = getInputTxtFileList(PatternStats.listFilesForFolder(folder));		iterator = allInputFileList.iterator();				BufferedWriter bw;		while( iterator.hasNext()) {			String currentFile = iterator.next();			if( !currentFile.contains(".txt")) continue;						String key = currentFile.split("_")[0];			br = new BufferedReader(new FileReader(inputDir + currentFile));			String outputFileName = currentFile.replace(".txt", ".csv");			bw = new BufferedWriter(new FileWriter(inputDir + outputFileName));	        //read user's input from file.//	        System.out.println("Input file path: " + args[0] + "\n");	        String test = "";			String line;			while ((line = br.readLine()) != null) {					test += (line + "\n");			}			br.close();		        System.out.println("Content of the input file:\n" + test );	        	        //extract the starred emotion word	        String targetWord = extractTargetWord(test);	        System.out.println("Target Emotion Word is: " + targetWord + "\n");	        String targetWordPOS = findTargetWordPOS(test, targetWord);	        test = test.replace("*", "");	        	        //look up the word on wordnet affect, find synsets	//        WordNetAffectDic.initialize();	        String tempSynSetStr = getSynsetStr(targetWord, targetWordPOS);//	        String tempSynSetStr = getSynsetStrAll(targetWord);	        System.out.println(tempSynSetStr);	        String previousWord = wordMap.get(key);	        tempSynSetStr = mergeSynStr(tempSynSetStr, targetWord);	        tempSynSetStr = mergeSynStr(tempSynSetStr, previousWord);	        String vocabSyns = VocabularyDotCom.getSynonyms(targetWord);	        System.out.println(vocabSyns);	        String synSetStr = mergeSynStr( tempSynSetStr, vocabSyns );//	        String synSetStr = (tempSynSetStr.contains(targetWord+" ")) ? tempSynSetStr: (targetWord + " " + tempSynSetStr);//	        synSetStr = getDoableSyns(synSetStr, emotionHash);	        	        bw.write(synSetStr.replaceAll("\\s+", "\n"));	       	        bw.close();		}    }    public static void generateCrossReferenceResult(String inputDir, String tag, String ourResult, String J1Result, String J2Result) throws IOException {    	final File folder = new File(inputDir);		ArrayList<String> allInputFileList = PatternStats.listFilesForFolder(folder);		ArrayList<String> inputTxtFileList = getInputTxtFileList(allInputFileList);    	    	ArrayList<HashMap<String, Integer>> J1Results = new ArrayList<HashMap<String, Integer>>();    	ArrayList<HashMap<String, Integer>> J2Results = new ArrayList<HashMap<String, Integer>>();    	    	BufferedReader br1 = new BufferedReader(new FileReader(J1Result));    	for(int i=0; i<240; i++) {    		HashMap<String, Integer> temp = new HashMap<String, Integer>();	    	String line;	    	while( (line = br1.readLine())!= null) {	    		if( line.length() < 1) continue;	    		if( line.matches("-\t-")) break;	    		else {	    			String[] tokens = line.split("\t");	    			if( !temp.containsKey(tokens[0]))	    				temp.put(tokens[0], Integer.valueOf(tokens[1]));	    		}	    	}	    	J1Results.add(temp);    	}    	br1.close();    	    	br1 = new BufferedReader(new FileReader(J2Result));    	for(int i=0; i<240; i++) {    		HashMap<String, Integer> temp = new HashMap<String, Integer>();	    	String line;	    	while( (line = br1.readLine())!= null) {	    		if( line.length() < 1) continue;	    		if( line.matches("-\t-")) {  				    			break;	    		}	    		else {	    			String[] tokens = line.split("\t");	    			if( !temp.containsKey(tokens[0]))	    				temp.put(tokens[0], Integer.valueOf(tokens[1]));	    		}	    	}	    	J2Results.add(temp);    	}    	br1.close();    	String outputFile = "crossRefer_" + tag + ".txt";    	BufferedReader br = new BufferedReader(new FileReader(ourResult));    	BufferedWriter bw = new BufferedWriter(new FileWriter(outputFile));    	  	    	String heading = String.format("%-15s %-12s %-10s %-10s\n", "Synonyms", tag+"_Ranking", "J1Ranking", "J2Ranking");    	bw.write(heading);    	    	for(int i=0; i<240; i++) {   		    		String line;//    		bw.write("-" + (i+1) +"\t-\n");    		bw.write("===@ " + inputTxtFileList.get(i) + " @===\n");    		while( (line=br.readLine())!= null) {    			if( line.length() < 1 ) continue;    			if( tag.equals("EDW") && line.matches("-\t-")) {//    				bw.write("\n");    				break;    			}    			else if( tag.equals("SVM") && line.matches("-\t-\\d+-"))    				break;    			else {    				String[] tokens = line.split("\t");    				Integer J1 = J1Results.get(i).get(tokens[0]);    				Integer J2 = J2Results.get(i).get(tokens[0]);    				String entry = String.format("%-15s %-12s %-10d %-10d\n", tokens[0], tokens[1], J1, J2);    				bw.write(entry);    			}    		}//    		bw.write("-\t-\n");    		bw.flush();    	}    	br.close();    	bw.close();    }    public static void debugMode(LexicalizedParser lp, String[] settings, boolean defaultSet) throws IOException, ClassNotFoundException, JWNLException {    	BufferedReader tmp = new BufferedReader(new InputStreamReader(System.in));    	    	String[] dirList = {"userInputs", "all240Articles"};    	String dirPath, filePath;    	int setChoice = 0;    	    	if(defaultSet == true) {    		dirPath = "all240Articles" + File.separator;    		System.out.println("Which file?");        	String fileName = tmp.readLine();        	filePath = dirPath + fileName;    	}    	else {	    	System.out.println("Choose Input File Directory:");	    	for(int i=0; i<dirList.length; i++)	    		System.out.println(i + ". " + dirList[i]);	    		    	String optionStr = tmp.readLine();	    	int dirChoice = Integer.valueOf(optionStr).intValue();	    	dirPath = dirList[dirChoice] + File.separator;	    		    	System.out.println("Which file?");	    	String fileName = tmp.readLine();	    	filePath = dirPath + fileName;	    		    		    	System.out.println("Choose Settings:");	    	for(int i=0; i<settings.length; i++) {	    		System.out.println(i + ". " + settings[i]);	    	}	    		    	setChoice = Integer.valueOf(tmp.readLine()).intValue();    	}    	executeSingle(filePath, settings[setChoice], lp, false);    	    }    public static void executeSingle(String filePath, String setting, LexicalizedParser lp, boolean doRegex) throws IOException, JWNLException, ClassNotFoundException{    	BufferedReader br = new BufferedReader(new FileReader(filePath));        //read user's input from file.//        System.out.println("Input file path: " + args[0] + "\n");        String test = "";		String line;		while ((line = br.readLine()) != null) {				test += (line + "\n");		}		br.close();	        System.out.println("Content of the input file:\n" + test );                //extract the starred emotion word        String targetWord = extractTargetWord(test);        System.out.println("Target Emotion Word is: " + targetWord + "\n");        String targetWordPOS = findTargetWordPOS(test, targetWord);        test = test.replace("*", "");                //look up the word on wordnet affect, find synsets//        WordNetAffectDic.initialize();        String tempSynSetStr = getSynsetStr(targetWord, targetWordPOS);        tempSynSetStr = mergeSynStr( tempSynSetStr, VocabularyDotCom.getSynonyms(targetWord));        String synSetStr = mergeSynStr( targetWord, tempSynSetStr);                System.out.println("Synonym cadidates:");        System.out.println(synSetStr + "\n");                //Process each synonyms//        ArrayList<Map.Entry<String, Double>> results = SynProcess.processVP(test, synSetStr, targetWord);//        ArrayList<Map.Entry<String, Double>> results = SynProcess.processPatternLocalSpecify(test, synSetStr, targetWord, lp, setting, doRegex);                ArrayList<String> patterns = PatternGenByDep.getPatternsFromText(test, targetWord, lp, false, true);    	ArrayList<String> synonyms = new ArrayList<String>(Arrays.asList(synSetStr.split(" ")));    	    	HashMap<String, Double> synonymScores = PatternStats.localTestSettingSpecifyDebug(patterns, synonyms, setting, doRegex);    	    }    public static ArrayList<String> getInputTxtFileList(ArrayList<String> allInputFiles) {    	ArrayList<String> inputTxtFileList = new ArrayList<String>();    	Iterator<String> iterator = allInputFiles.iterator();    	while( iterator.hasNext()) {    		String currentFile = iterator.next();    		if( !currentFile.contains(".txt")) continue;    		inputTxtFileList.add(currentFile);    	}    	Collections.sort(inputTxtFileList);    	return inputTxtFileList;    }    public static void executeSynReplaceSpecify(String inputDir, LexicalizedParser lp, String settingPath, boolean doRegex, boolean usePPL) throws IOException, JWNLException, ClassNotFoundException{//    	int amount = 5;    	int number = 1;    	final File folder = new File(inputDir);		ArrayList<String> allInputFileList = PatternStats.listFilesForFolder(folder);		ArrayList<String> inputTxtFileList = getInputTxtFileList(allInputFileList);		Iterator<String> iterator = inputTxtFileList.iterator();		BufferedReader br;		BufferedWriter bw, bw3;		String prefix = "Output33_fixEDW_allRes_";		if( doRegex == true)			prefix += "Regex_";		else			prefix += "EDW_";		bw = new BufferedWriter(new FileWriter(prefix + settingPath));//		bw3 = new BufferedWriter(new FileWriter("Process_order.txt"));		System.out.println("Setting = " + settingPath.replace(".txt", "") + ":");		while( iterator.hasNext()) {			String currentFile = iterator.next();			if( !currentFile.contains(".txt")) continue;						br = new BufferedReader(new FileReader(inputDir + currentFile));	        //read user's input from file.//	        System.out.println("Input file path: " + args[0] + "\n");	        String test = "";			String line;			while ((line = br.readLine()) != null) {					test += (line + "\n");			}			br.close();				System.out.println("File = " + currentFile);	        System.out.println("Content of the input file:\n" + test );	        	        //extract the starred emotion word	        String targetWord = extractTargetWord(test);	        System.out.println("Target Emotion Word is: " + targetWord + "\n");	        String targetWordPOS = findTargetWordPOS(test, targetWord);	        test = test.replace("*", "");	        //			bw3.write(currentFile+"\t"+targetWordPOS+"\n");//	        /*	        //look up the word on wordnet affect, find synsets	//        WordNetAffectDic.initialize();	        String tempSynSetStr = getSynsetStr(targetWord, targetWordPOS);	        tempSynSetStr = mergeSynStr( tempSynSetStr, VocabularyDotCom.getSynonyms(targetWord));	        String synSetStr = mergeSynStr( targetWord.toLowerCase(), tempSynSetStr);//	        String synSetStr="positive negative neutral null";	        System.out.println("Synonym cadidates:");	        System.out.println(synSetStr + "\n");	        	        //Process each synonyms	//        ArrayList<Map.Entry<String, Double>> results = SynProcess.processVP(test, synSetStr, targetWord);	        ArrayList<Map.Entry<String, Double>> results = SynProcess.processPatternLocalSpecify(test, synSetStr, targetWord, lp, settingPath, doRegex, usePPL);//	        ArrayList<synResult> orderedResults = PatternStats.getOrderedResults(results);	        //	        System.out.print("\nSuggested synonym (top " + amount + "): ");	        System.out.print("\nSuggested synonym (all) ");//	        System.out.println(results.size());	        if( results.size() != 0) {				Iterator it = results.iterator();//				int current = 0;				int current = 1;				while (it.hasNext()) {					String[] entryString = it.next().toString().split("=");		//			System.out.print(entryString[0] + " ");					System.out.print(entryString[0]+"("+entryString[1]+")"+" ");					//					bw.write(entryString[0] + "\t" + (amount+1-current) + "\n");					bw.write(entryString[0] + "\t" + current + "\n");										current++;//					if( current == amount)//						break;				}				System.out.println();			}	        else {	        	bw.write("\n");	        	System.out.println(targetWord);	        }	        bw.write("-\t-"+number+"-\n");	        number++;	        bw.flush();			System.out.print("=====================================\n"); //			*/		} 		bw.close();//		bw3.close();    }    public static void executeSynReplaceSpecifyPrepareTest(String inputDir, LexicalizedParser lp, String settingPath, boolean doRegex, boolean usePPL) throws IOException, JWNLException, ClassNotFoundException{//    	int amount = 5;    	int number = 1;    	final File folder = new File(inputDir);		ArrayList<String> allInputFileList = PatternStats.listFilesForFolder(folder);		ArrayList<String> inputTxtFileList = getInputTxtFileList(allInputFileList);		Iterator<String> iterator = inputTxtFileList.iterator();		BufferedReader br;		BufferedWriter bw, bw3;		String prefix = "./NewExpSynonym/";				System.out.println("Setting = " + settingPath.replace(".txt", "") + ":");		while( iterator.hasNext()) {			String currentFile = iterator.next();			if( !currentFile.contains(".txt")) continue;			br = new BufferedReader(new FileReader(inputDir + currentFile));	        String test = "";			String line;			while ((line = br.readLine()) != null) {					test += (line + "\n");			}			br.close();				System.out.println("File = " + currentFile);	        System.out.println("Content of the input file:\n" + test );	        	        String targetWord = extractTargetWord(test);	        if(targetWord.isEmpty()) continue;	        System.out.println("Target Emotion Word is: " + targetWord + "\n");	        String targetWordPOS = findTargetWordPOS(test, targetWord);	        test = test.replace("*", "");	        String tempSynSetStr = getSynsetStr(targetWord, targetWordPOS);	        tempSynSetStr = mergeSynStr( tempSynSetStr, VocabularyDotCom.getSynonyms(targetWord));	        String[] synSetStr = mergeSynStr( targetWord.toLowerCase(), tempSynSetStr).split(" ");	        bw = new BufferedWriter(new FileWriter(prefix + currentFile));	        System.out.println("Synonym cadidates:");	        System.out.println(synSetStr + "\n");	        for(int i=0;i<synSetStr.length;i++)	        	bw.write(synSetStr[i] + "\n");	        	        bw.close();		}     }    public static void executeSynReplaceSpecify_reForm(String inputDir, LexicalizedParser lp, String settingPath, String PeFile, boolean doRegex, boolean usePPL) throws IOException, JWNLException, ClassNotFoundException{//    	int amount = 5;    	int number = 1;    	final File folder = new File(inputDir);		ArrayList<String> allInputFileList = PatternStats.listFilesForFolder(folder);		ArrayList<String> inputTxtFileList = getInputTxtFileList(allInputFileList);		Iterator<String> iterator = inputTxtFileList.iterator();		BufferedReader br;		BufferedWriter bw, bw3;		String prefix = "Output_lnlnpriorfixEDW_allRes_";		if( doRegex == true)			prefix += "Regex_";		else			prefix += "EDW_";		bw = new BufferedWriter(new FileWriter(prefix + settingPath));//		bw3 = new BufferedWriter(new FileWriter("Process_order.txt"));		System.out.println("Setting = " + settingPath.replace(".txt", "") + ":");		while( iterator.hasNext()) {			String currentFile = iterator.next();			if( !currentFile.contains(".txt")) continue;						br = new BufferedReader(new FileReader(inputDir + currentFile));	        //read user's input from file.//	        System.out.println("Input file path: " + args[0] + "\n");	        String test = "";			String line;			while ((line = br.readLine()) != null) {					test += (line + "\n");			}			br.close();				System.out.println("File = " + currentFile);	        System.out.println("Content of the input file:\n" + test );	        	        //extract the starred emotion word	        String targetWord = extractTargetWord(test);	        System.out.println("Target Emotion Word is: " + targetWord + "\n");	        String targetWordPOS = findTargetWordPOS(test, targetWord);	        test = test.replace("*", "");	        //			bw3.write(currentFile+"\t"+targetWordPOS+"\n");//	        /*	        //look up the word on wordnet affect, find synsets	//        WordNetAffectDic.initialize();	        String tempSynSetStr = getSynsetStr(targetWord, targetWordPOS);	        tempSynSetStr = mergeSynStr( tempSynSetStr, VocabularyDotCom.getSynonyms(targetWord));	        String synSetStr = mergeSynStr( targetWord.toLowerCase(), tempSynSetStr);//	        String synSetStr="positive negative neutral null";	        System.out.println("Synonym cadidates:");	        System.out.println(synSetStr + "\n");	        	        //Process each synonyms	//        ArrayList<Map.Entry<String, Double>> results = SynProcess.processVP(test, synSetStr, targetWord);	        ArrayList<Map.Entry<String, Double>> results = SynProcess.processPatternLocalSpecify_reForm(test, synSetStr, targetWord, lp, settingPath, PeFile, doRegex, usePPL);//	        ArrayList<synResult> orderedResults = PatternStats.getOrderedResults(results);	        //	        System.out.print("\nSuggested synonym (top " + amount + "): ");	        System.out.print("\nSuggested synonym (all) ");//	        System.out.println(results.size());	        if( results.size() != 0) {				Iterator it = results.iterator();//				int current = 0;				int current = 1;				while (it.hasNext()) {					String[] entryString = it.next().toString().split("=");		//			System.out.print(entryString[0] + " ");					System.out.print(entryString[0]+"("+entryString[1]+")"+" ");					//					bw.write(entryString[0] + "\t" + (amount+1-current) + "\n");					bw.write(entryString[0] + "\t" + current + "\n");										current++;//					if( current == amount)//						break;				}				System.out.println();			}	        else {	        	bw.write("\n");	        	System.out.println(targetWord);	        }	        bw.write("-\t-"+number+"-\n");	        number++;	        bw.flush();			System.out.print("=====================================\n"); //			*/		} 		bw.close();//		bw3.close();    }    public static void executeSynReplaceSpecify_weight(String inputDir, LexicalizedParser lp, String settingPath, String weightFile, boolean doRegex, boolean usePPL) throws IOException, JWNLException, ClassNotFoundException{//    	int amount = 5;    	int number = 1;    	final File folder = new File(inputDir);		ArrayList<String> allInputFileList = PatternStats.listFilesForFolder(folder);		ArrayList<String> inputTxtFileList = getInputTxtFileList(allInputFileList);		Iterator<String> iterator = inputTxtFileList.iterator();		BufferedReader br;		BufferedWriter bw, bw3;		String prefix = "Output_allRes_LexRank_";		if( doRegex == true)			prefix += "Regex_";		else			prefix += "EDW_";		bw = new BufferedWriter(new FileWriter(prefix + settingPath));//		bw3 = new BufferedWriter(new FileWriter("Process_order.txt"));		System.out.println("Setting = " + settingPath.replace(".txt", "") + ":");		while( iterator.hasNext()) {			String currentFile = iterator.next();			if( !currentFile.contains(".txt")) continue;						br = new BufferedReader(new FileReader(inputDir + currentFile));	        //read user's input from file.//	        System.out.println("Input file path: " + args[0] + "\n");	        String test = "";			String line;			while ((line = br.readLine()) != null) {					test += (line + "\n");			}			br.close();				System.out.println("File = " + currentFile);	        System.out.println("Content of the input file:\n" + test );	        	        //extract the starred emotion word	        String targetWord = extractTargetWord(test);	        System.out.println("Target Emotion Word is: " + targetWord + "\n");	        String targetWordPOS = findTargetWordPOS(test, targetWord);	        test = test.replace("*", "");	        //			bw3.write(currentFile+"\t"+targetWordPOS+"\n");//	        /*	        //look up the word on wordnet affect, find synsets	//        WordNetAffectDic.initialize();	        String tempSynSetStr = getSynsetStr(targetWord, targetWordPOS);	        tempSynSetStr = mergeSynStr( tempSynSetStr, VocabularyDotCom.getSynonyms(targetWord));	        String synSetStr = mergeSynStr( targetWord.toLowerCase(), tempSynSetStr);//	        String synSetStr="positive negative neutral null";	        System.out.println("Synonym cadidates:");	        System.out.println(synSetStr + "\n");	        	        //Process each synonyms	//        ArrayList<Map.Entry<String, Double>> results = SynProcess.processVP(test, synSetStr, targetWord);	        ArrayList<Map.Entry<String, Double>> results = SynProcess.processPatternLocalSpecify_weight(test, synSetStr, targetWord, lp, settingPath, weightFile, doRegex, usePPL);//	        ArrayList<synResult> orderedResults = PatternStats.getOrderedResults(results);	        //	        System.out.print("\nSuggested synonym (top " + amount + "): ");	        System.out.print("\nSuggested synonym (all) ");//	        System.out.println(results.size());	        if( results.size() != 0) {				Iterator it = results.iterator();//				int current = 0;				int current = 1;				while (it.hasNext()) {					String[] entryString = it.next().toString().split("=");		//			System.out.print(entryString[0] + " ");					System.out.print(entryString[0]+"("+entryString[1]+")"+" ");					//					bw.write(entryString[0] + "\t" + (amount+1-current) + "\n");					bw.write(entryString[0] + "\t" + current + "\n");										current++;//					if( current == amount)//						break;				}				System.out.println();			}	        else {	        	bw.write("\n");	        	System.out.println(targetWord);	        }	        bw.write("-\t-"+number+"-\n");	        number++;	        bw.flush();			System.out.print("=====================================\n"); //			*/		} 		bw.close();//		bw3.close();    }    public static void executeSynReplaceSpecify_N_E(String inputDir, LexicalizedParser lp, String settingPath, boolean doRegex, boolean usePPL,boolean useE, boolean useN) throws IOException, JWNLException, ClassNotFoundException{//    	int amount = 5;    	int number = 1;    	final File folder = new File(inputDir);		ArrayList<String> allInputFileList = PatternStats.listFilesForFolder(folder);		ArrayList<String> inputTxtFileList = getInputTxtFileList(allInputFileList);		Iterator<String> iterator = inputTxtFileList.iterator();		BufferedReader br;		BufferedWriter bw, bw3;		String prefix = "Output_allRes_";		if( doRegex == true)			prefix += "Regex_";		else			prefix += "EDW_";		bw = new BufferedWriter(new FileWriter(prefix + settingPath));//		bw3 = new BufferedWriter(new FileWriter("Process_order.txt"));		System.out.println("Setting = " + settingPath.replace(".txt", "") + ":");		while( iterator.hasNext()) {			String currentFile = iterator.next();			if( !currentFile.contains(".txt")) continue;						br = new BufferedReader(new FileReader(inputDir + currentFile));	        //read user's input from file.//	        System.out.println("Input file path: " + args[0] + "\n");	        String test = "";			String line;			while ((line = br.readLine()) != null) {					test += (line + "\n");			}			br.close();				System.out.println("File = " + currentFile);	        System.out.println("Content of the input file:\n" + test );	        	        //extract the starred emotion word	        String targetWord = extractTargetWord(test);	        System.out.println("Target Emotion Word is: " + targetWord + "\n");	        String targetWordPOS = findTargetWordPOS(test, targetWord);	        test = test.replace("*", "");	        //			bw3.write(currentFile+"\t"+targetWordPOS+"\n");//	        /*	        //look up the word on wordnet affect, find synsets	//        WordNetAffectDic.initialize();	        String tempSynSetStr = getSynsetStr(targetWord, targetWordPOS);	        tempSynSetStr = mergeSynStr( tempSynSetStr, VocabularyDotCom.getSynonyms(targetWord));	        String synSetStr = mergeSynStr( targetWord.toLowerCase(), tempSynSetStr);//	        String synSetStr="positive negative neutral null";	        System.out.println("Synonym cadidates:");	        System.out.println(synSetStr + "\n");	        	        //Process each synonyms	//        ArrayList<Map.Entry<String, Double>> results = SynProcess.processVP(test, synSetStr, targetWord);	        ArrayList<Map.Entry<String, Double>> results = SynProcess.processPatternLocalSpecify_N_E(test, synSetStr, targetWord, lp, settingPath, doRegex, usePPL,useE,useN);//	        ArrayList<synResult> orderedResults = PatternStats.getOrderedResults(results);	        //	        System.out.print("\nSuggested synonym (top " + amount + "): ");	        System.out.print("\nSuggested synonym (all) ");//	        System.out.println(results.size());	        if( results.size() != 0) {				Iterator it = results.iterator();//				int current = 0;				int current = 1;				while (it.hasNext()) {					String[] entryString = it.next().toString().split("=");		//			System.out.print(entryString[0] + " ");					System.out.print(entryString[0]+"("+entryString[1]+")"+" ");					//					bw.write(entryString[0] + "\t" + (amount+1-current) + "\n");					bw.write(entryString[0] + "\t" + current + "\n");										current++;//					if( current == amount)//						break;				}				System.out.println();			}	        else {	        	bw.write("\n");	        	System.out.println(targetWord);	        }	        bw.write("-\t-"+number+"-\n");	        number++;	        bw.flush();			System.out.print("=====================================\n"); //			*/		} 		bw.close();//		bw3.close();    }    public static void executeSynReplaceSpecify_N_E_add(String inputDir, LexicalizedParser lp, String settingPath, boolean doRegex, boolean usePPL,boolean useE, boolean useN) throws IOException, JWNLException, ClassNotFoundException{//    	int amount = 5;    	int number = 1;    	final File folder = new File(inputDir);		ArrayList<String> allInputFileList = PatternStats.listFilesForFolder(folder);		ArrayList<String> inputTxtFileList = getInputTxtFileList(allInputFileList);		Iterator<String> iterator = inputTxtFileList.iterator();		BufferedReader br;		BufferedWriter bw, bw3;		String prefix = "Output_mod240_allRes_add_ps1_";		if( doRegex == true)			prefix += "Regex_";		else			prefix += "EDW_";		bw = new BufferedWriter(new FileWriter(prefix + settingPath));//		bw3 = new BufferedWriter(new FileWriter("Process_order.txt"));		System.out.println("Setting = " + settingPath.replace(".txt", "") + ":");		while( iterator.hasNext()) {			String currentFile = iterator.next();			if( !currentFile.contains(".txt")) continue;						br = new BufferedReader(new FileReader(inputDir + currentFile));	        //read user's input from file.//	        System.out.println("Input file path: " + args[0] + "\n");	        String test = "";			String line;			while ((line = br.readLine()) != null) {					test += (line + "\n");			}			br.close();				System.out.println("File = " + currentFile);	        System.out.println("Content of the input file:\n" + test );	        	        //extract the starred emotion word	        String targetWord = extractTargetWord(test);	        System.out.println("Target Emotion Word is: " + targetWord + "\n");	        String targetWordPOS = findTargetWordPOS(test, targetWord);	        test = test.replace("*", "");	        //			bw3.write(currentFile+"\t"+targetWordPOS+"\n");//	        /*	        //look up the word on wordnet affect, find synsets	//        WordNetAffectDic.initialize();	        String tempSynSetStr = getSynsetStr(targetWord, targetWordPOS);	        tempSynSetStr = mergeSynStr( tempSynSetStr, VocabularyDotCom.getSynonyms(targetWord));	        String synSetStr = mergeSynStr( targetWord.toLowerCase(), tempSynSetStr);//	        String synSetStr="positive negative neutral null";	        System.out.println("Synonym cadidates:");	        System.out.println(synSetStr + "\n");	        	        //Process each synonyms	//        ArrayList<Map.Entry<String, Double>> results = SynProcess.processVP(test, synSetStr, targetWord);	        ArrayList<Map.Entry<String, Double>> results = SynProcess.processPatternLocalSpecify_N_E_add(test, synSetStr, targetWord, lp, settingPath, doRegex, usePPL,useE,useN);//	        ArrayList<synResult> orderedResults = PatternStats.getOrderedResults(results);	        //	        System.out.print("\nSuggested synonym (top " + amount + "): ");	        System.out.print("\nSuggested synonym (all) ");//	        System.out.println(results.size());	        if( results.size() != 0) {				Iterator it = results.iterator();//				int current = 0;				int current = 1;				while (it.hasNext()) {					String[] entryString = it.next().toString().split("=");		//			System.out.print(entryString[0] + " ");					System.out.print(entryString[0]+"("+entryString[1]+")"+" ");					//					bw.write(entryString[0] + "\t" + (amount+1-current) + "\n");					bw.write(entryString[0] + "\t" + current + "\n");										current++;//					if( current == amount)//						break;				}				System.out.println();			}	        else {	        	bw.write("\n");	        	System.out.println(targetWord);	        }	        bw.write("-\t-"+number+"-\n");	        number++;	        bw.flush();			System.out.print("=====================================\n"); //			*/		} 		bw.close();//		bw3.close();    }    public static void executeSynReplaceSpecify_N_E_add_opp(String inputDir, LexicalizedParser lp, String settingPath, boolean doRegex, boolean usePPL,boolean useE, boolean useN) throws IOException, JWNLException, ClassNotFoundException{//    	int amount = 5;    	int number = 1;    	final File folder = new File(inputDir);		ArrayList<String> allInputFileList = PatternStats.listFilesForFolder(folder);		ArrayList<String> inputTxtFileList = getInputTxtFileList(allInputFileList);		Iterator<String> iterator = inputTxtFileList.iterator();		BufferedReader br;		BufferedWriter bw, bw3;		String prefix = "Output_mod240_allRes_add_ps1_opp_";		if( doRegex == true)			prefix += "Regex_";		else			prefix += "EDW_";		bw = new BufferedWriter(new FileWriter(prefix + settingPath));//		bw3 = new BufferedWriter(new FileWriter("Process_order.txt"));		System.out.println("Setting = " + settingPath.replace(".txt", "") + ":");		while( iterator.hasNext()) {			String currentFile = iterator.next();			if( !currentFile.contains(".txt")) continue;						br = new BufferedReader(new FileReader(inputDir + currentFile));	        //read user's input from file.//	        System.out.println("Input file path: " + args[0] + "\n");	        String test = "";			String line;			while ((line = br.readLine()) != null) {					test += (line + "\n");			}			br.close();				System.out.println("File = " + currentFile);	        System.out.println("Content of the input file:\n" + test );	        	        //extract the starred emotion word	        String targetWord = extractTargetWord(test);	        System.out.println("Target Emotion Word is: " + targetWord + "\n");	        String targetWordPOS = findTargetWordPOS(test, targetWord);	        test = test.replace("*", "");	        //			bw3.write(currentFile+"\t"+targetWordPOS+"\n");//	        /*	        //look up the word on wordnet affect, find synsets	//        WordNetAffectDic.initialize();	        String tempSynSetStr = getSynsetStr(targetWord, targetWordPOS);	        tempSynSetStr = mergeSynStr( tempSynSetStr, VocabularyDotCom.getSynonyms(targetWord));	        String synSetStr = mergeSynStr( targetWord.toLowerCase(), tempSynSetStr);//	        String synSetStr="positive negative neutral null";	        System.out.println("Synonym cadidates:");	        System.out.println(synSetStr + "\n");	        	        //Process each synonyms	//        ArrayList<Map.Entry<String, Double>> results = SynProcess.processVP(test, synSetStr, targetWord);	        ArrayList<Map.Entry<String, Double>> results = SynProcess.processPatternLocalSpecify_N_E_add_opp(currentFile, test, synSetStr, targetWord, lp, settingPath, doRegex, usePPL,useE,useN);//	        ArrayList<synResult> orderedResults = PatternStats.getOrderedResults(results);	        //	        System.out.print("\nSuggested synonym (top " + amount + "): ");	        System.out.print("\nSuggested synonym (all) ");//	        System.out.println(results.size());	        if( results.size() != 0) {				Iterator it = results.iterator();//				int current = 0;				int current = 1;				while (it.hasNext()) {					String[] entryString = it.next().toString().split("=");		//			System.out.print(entryString[0] + " ");					System.out.print(entryString[0]+"("+entryString[1]+")"+" ");					//					bw.write(entryString[0] + "\t" + (amount+1-current) + "\n");					bw.write(entryString[0] + "\t" + current + "\n");										current++;//					if( current == amount)//						break;				}				System.out.println();			}	        else {	        	bw.write("\n");	        	System.out.println(targetWord);	        }	        bw.write("-\t-"+number+"-\n");	        number++;	        bw.flush();			System.out.print("=====================================\n"); //			*/		} 		bw.close();//		bw3.close();    }    public static void executeSynReplaceSpecifyWord(String inputDir, LexicalizedParser lp, String settingPath, boolean doRegex, boolean usePPL) throws IOException, JWNLException, ClassNotFoundException{//    	int amount = 5;    	int number = 1;    	final File folder = new File(inputDir);		ArrayList<String> allInputFileList = PatternStats.listFilesForFolder(folder);		ArrayList<String> inputTxtFileList = getInputTxtFileList(allInputFileList);		Iterator<String> iterator = inputTxtFileList.iterator();		BufferedReader br;		BufferedWriter bw, bw3;		String prefix = "240Output_Word_allRes_";		if( doRegex == true)			prefix += "Regex_";		else			prefix += "EDW_";		bw = new BufferedWriter(new FileWriter(prefix + settingPath));//		bw3 = new BufferedWriter(new FileWriter("Process_order.txt"));		System.out.println("Setting = " + settingPath.replace(".txt", "") + ":");		while( iterator.hasNext()) {			String currentFile = iterator.next();			if( !currentFile.contains(".txt")) continue;						br = new BufferedReader(new FileReader(inputDir + currentFile));	        //read user's input from file.//	        System.out.println("Input file path: " + args[0] + "\n");	        String test = "";			String line;			while ((line = br.readLine()) != null) {					test += (line + "\n");			}			br.close();				System.out.println("File = " + currentFile);	        System.out.println("Content of the input file:\n" + test );	        	        //extract the starred emotion word	        String targetWord = extractTargetWord(test);	        System.out.println("Target Emotion Word is: " + targetWord + "\n");	        String targetWordPOS = findTargetWordPOS(test, targetWord);	        test = test.replace("*", "");	        //			bw3.write(currentFile+"\t"+targetWordPOS+"\n");//	        /*	        //look up the word on wordnet affect, find synsets	//        WordNetAffectDic.initialize();	        String tempSynSetStr = getSynsetStr(targetWord, targetWordPOS);	        tempSynSetStr = mergeSynStr( tempSynSetStr, VocabularyDotCom.getSynonyms(targetWord));	        String synSetStr = mergeSynStr( targetWord, tempSynSetStr);	        	        System.out.println("Synonym cadidates:");	        System.out.println(synSetStr + "\n");	        	        //Process each synonyms	//        ArrayList<Map.Entry<String, Double>> results = SynProcess.processVP(test, synSetStr, targetWord);	        ArrayList<Map.Entry<String, Double>> results = SynProcess.processPatternLocalSpecifyWord(test, synSetStr, targetWord, lp, settingPath, doRegex, usePPL);//	        ArrayList<synResult> orderedResults = PatternStats.getOrderedResults(results);	        //	        System.out.print("\nSuggested synonym (top " + amount + "): ");	        System.out.print("\nSuggested synonym (all) ");	        if( results.size() != 0) {				Iterator it = results.iterator();//				int current = 0;				int current = 1;				while (it.hasNext()) {					String[] entryString = it.next().toString().split("=");		//			System.out.print(entryString[0] + " ");					System.out.print(entryString[0]+"("+entryString[1]+")"+" ");					//					bw.write(entryString[0] + "\t" + (amount+1-current) + "\n");					bw.write(entryString[0] + "\t" + current + "\n");										current++;//					if( current == amount)//						break;				}				System.out.println();			}	        else {	        	bw.write("\n");	        	System.out.println(targetWord);	        }	        bw.write("-\t-"+number+"-\n");	        number++;	        bw.flush();			System.out.print("=====================================\n"); //			*/		} 		bw.close();//		bw3.close();    }        public static void executeSynReplaceSpecifyDice(String inputDir, LexicalizedParser lp, String settingPath, boolean doRegex, boolean usePPL) throws IOException, JWNLException, ClassNotFoundException{//    	int amount = 5;    	int number = 1;    	final File folder = new File(inputDir);		ArrayList<String> allInputFileList = PatternStats.listFilesForFolder(folder);		ArrayList<String> inputTxtFileList = getInputTxtFileList(allInputFileList);		TreeMap<String,Double> patternStat = DiceBuildStat("patternStat.txt");		TreeMap<String,Double> emoStat = DiceBuildStat("emoStat.txt");		Iterator<String> iterator = inputTxtFileList.iterator();		BufferedReader br;		BufferedWriter bw, bw3;		String prefix = "240Output_Dice_allRes_";		if( doRegex == true)			prefix += "Regex_";		else			prefix += "EDW_";		bw = new BufferedWriter(new FileWriter(prefix + settingPath));//		bw3 = new BufferedWriter(new FileWriter("Process_order.txt"));		System.out.println("Setting = " + settingPath.replace(".txt", "") + ":");		while( iterator.hasNext()) {			String currentFile = iterator.next();			if( !currentFile.contains(".txt")) continue;						br = new BufferedReader(new FileReader(inputDir + currentFile));	        //read user's input from file.//	        System.out.println("Input file path: " + args[0] + "\n");	        String test = "";			String line;			while ((line = br.readLine()) != null) {					test += (line + "\n");			}			br.close();				System.out.println("File = " + currentFile);	        System.out.println("Content of the input file:\n" + test );	        	        //extract the starred emotion word	        String targetWord = extractTargetWord(test);	        System.out.println("Target Emotion Word is: " + targetWord + "\n");	        String targetWordPOS = findTargetWordPOS(test, targetWord);	        test = test.replace("*", "");	        //			bw3.write(currentFile+"\t"+targetWordPOS+"\n");//	        /*	        //look up the word on wordnet affect, find synsets	//        WordNetAffectDic.initialize();	        String tempSynSetStr = getSynsetStr(targetWord, targetWordPOS);	        tempSynSetStr = mergeSynStr( tempSynSetStr, VocabularyDotCom.getSynonyms(targetWord));	        String synSetStr = mergeSynStr( targetWord, tempSynSetStr);	        	        System.out.println("Synonym cadidates:");	        System.out.println(synSetStr + "\n");	        	        //Process each synonyms	//        ArrayList<Map.Entry<String, Double>> results = SynProcess.processVP(test, synSetStr, targetWord);//	        ArrayList<Map.Entry<String, Double>> results = SynProcess.processPatternLocalSpecify(test, synSetStr, targetWord, lp, settingPath, doRegex, usePPL);	        ArrayList<Map.Entry<String, Double>> results = SynProcess.processPatternLocalSpecifyDice(test, synSetStr, targetWord, lp, settingPath, doRegex, usePPL, patternStat, emoStat);        //	        ArrayList<synResult> orderedResults = PatternStats.getOrderedResults(results);	        //	        System.out.print("\nSuggested synonym (top " + amount + "): ");	        System.out.print("\nSuggested synonym (all) ");	        if( results.size() != 0) {				Iterator it = results.iterator();//				int current = 0;				int current = 1;				while (it.hasNext()) {					String[] entryString = it.next().toString().split("=");		//			System.out.print(entryString[0] + " ");					System.out.print(entryString[0]+"("+entryString[1]+")"+" ");					//					bw.write(entryString[0] + "\t" + (amount+1-current) + "\n");					bw.write(entryString[0] + "\t" + current + "\n");										current++;//					if( current == amount)//						break;				}				System.out.println();			}	        else {	        	bw.write("\n");	        	System.out.println(targetWord);	        }	        bw.write("-\t-"+number+"-\n");	        number++;	        bw.flush();			System.out.print("=====================================\n"); //			*/		} 		bw.close();//		bw3.close();    }    public static void executeSynReplaceSpecifyPMI(String inputDir, LexicalizedParser lp, String settingPath, boolean doRegex, boolean usePPL) throws IOException, JWNLException, ClassNotFoundException{//    	int amount = 5;    	int number = 1;    	final File folder = new File(inputDir);		ArrayList<String> allInputFileList = PatternStats.listFilesForFolder(folder);		ArrayList<String> inputTxtFileList = getInputTxtFileList(allInputFileList);		TreeMap<String,Double> patternStat = DiceBuildStat("patternStat.txt");		TreeMap<String,Double> emoStat = DiceBuildStat("emoStat.txt");		Iterator<String> iterator = inputTxtFileList.iterator();		BufferedReader br;		BufferedWriter bw, bw3;		String prefix = "240Output_PMI_allRes_";		if( doRegex == true)			prefix += "Regex_";		else			prefix += "EDW_";		bw = new BufferedWriter(new FileWriter(prefix + settingPath));//		bw3 = new BufferedWriter(new FileWriter("Process_order.txt"));		System.out.println("Setting = " + settingPath.replace(".txt", "") + ":");		while( iterator.hasNext()) {			String currentFile = iterator.next();			if( !currentFile.contains(".txt")) continue;						br = new BufferedReader(new FileReader(inputDir + currentFile));	        //read user's input from file.//	        System.out.println("Input file path: " + args[0] + "\n");	        String test = "";			String line;			while ((line = br.readLine()) != null) {					test += (line + "\n");			}			br.close();				System.out.println("File = " + currentFile);	        System.out.println("Content of the input file:\n" + test );	        	        //extract the starred emotion word	        String targetWord = extractTargetWord(test);	        System.out.println("Target Emotion Word is: " + targetWord + "\n");	        String targetWordPOS = findTargetWordPOS(test, targetWord);	        test = test.replace("*", "");	        //			bw3.write(currentFile+"\t"+targetWordPOS+"\n");//	        /*	        //look up the word on wordnet affect, find synsets	//        WordNetAffectDic.initialize();	        String tempSynSetStr = getSynsetStr(targetWord, targetWordPOS);	        tempSynSetStr = mergeSynStr( tempSynSetStr, VocabularyDotCom.getSynonyms(targetWord));	        String synSetStr = mergeSynStr( targetWord, tempSynSetStr);	        	        System.out.println("Synonym cadidates:");	        System.out.println(synSetStr + "\n");	        	        //Process each synonyms	//        ArrayList<Map.Entry<String, Double>> results = SynProcess.processVP(test, synSetStr, targetWord);//	        ArrayList<Map.Entry<String, Double>> results = SynProcess.processPatternLocalSpecify(test, synSetStr, targetWord, lp, settingPath, doRegex, usePPL);//	        ArrayList<Map.Entry<String, Double>> results = SynProcess.processPatternLocalSpecifyDice(test, synSetStr, targetWord, lp, settingPath, doRegex, usePPL, patternStat, emoStat);        	        ArrayList<Map.Entry<String, Double>> results = SynProcess.processPatternLocalSpecifyPMI(test, synSetStr, targetWord, lp, settingPath, doRegex, usePPL, patternStat, emoStat);        //	        ArrayList<synResult> orderedResults = PatternStats.getOrderedResults(results);	        //	        System.out.print("\nSuggested synonym (top " + amount + "): ");	        System.out.print("\nSuggested synonym (all) ");	        if( results.size() != 0) {				Iterator it = results.iterator();//				int current = 0;				int current = 1;				while (it.hasNext()) {					String[] entryString = it.next().toString().split("=");		//			System.out.print(entryString[0] + " ");					System.out.print(entryString[0]+"("+entryString[1]+")"+" ");					//					bw.write(entryString[0] + "\t" + (amount+1-current) + "\n");					bw.write(entryString[0] + "\t" + current + "\n");										current++;//					if( current == amount)//						break;				}				System.out.println();			}	        else {	        	bw.write("\n");	        	System.out.println(targetWord);	        }	        bw.write("-\t-"+number+"-\n");	        number++;	        bw.flush();			System.out.print("=====================================\n"); //			*/		} 		bw.close();//		bw3.close();    }    public static void executeSynReplaceSpecifyTFIDF(String inputDir, LexicalizedParser lp, String settingPath, boolean doRegex, boolean usePPL) throws IOException, JWNLException, ClassNotFoundException{//    	int amount = 5;    	int number = 1;    	final File folder = new File(inputDir);		ArrayList<String> allInputFileList = PatternStats.listFilesForFolder(folder);		ArrayList<String> inputTxtFileList = getInputTxtFileList(allInputFileList);		TreeMap<String,Double> patternStat = DiceBuildStat("patternStat.txt");		TreeMap<String,Double> emoStat = DiceBuildStat("emoStat.txt");		Iterator<String> iterator = inputTxtFileList.iterator();		BufferedReader br;		BufferedWriter bw, bw3;		String prefix = "240Output_TFIDF_allRes_";		if( doRegex == true)			prefix += "Regex_";		else			prefix += "EDW_";		bw = new BufferedWriter(new FileWriter(prefix + settingPath));//		bw3 = new BufferedWriter(new FileWriter("Process_order.txt"));		System.out.println("Setting = " + settingPath.replace(".txt", "") + ":");		while( iterator.hasNext()) {			String currentFile = iterator.next();			if( !currentFile.contains(".txt")) continue;						br = new BufferedReader(new FileReader(inputDir + currentFile));	        //read user's input from file.//	        System.out.println("Input file path: " + args[0] + "\n");	        String test = "";			String line;			while ((line = br.readLine()) != null) {					test += (line + "\n");			}			br.close();				System.out.println("File = " + currentFile);	        System.out.println("Content of the input file:\n" + test );	        	        //extract the starred emotion word	        String targetWord = extractTargetWord(test);	        System.out.println("Target Emotion Word is: " + targetWord + "\n");	        String targetWordPOS = findTargetWordPOS(test, targetWord);	        test = test.replace("*", "");	        //			bw3.write(currentFile+"\t"+targetWordPOS+"\n");//	        /*	        //look up the word on wordnet affect, find synsets	//        WordNetAffectDic.initialize();	        String tempSynSetStr = getSynsetStr(targetWord, targetWordPOS);	        tempSynSetStr = mergeSynStr( tempSynSetStr, VocabularyDotCom.getSynonyms(targetWord));	        String synSetStr = mergeSynStr( targetWord, tempSynSetStr);	        	        System.out.println("Synonym cadidates:");	        System.out.println(synSetStr + "\n");	        	        //Process each synonyms	//        ArrayList<Map.Entry<String, Double>> results = SynProcess.processVP(test, synSetStr, targetWord);//	        ArrayList<Map.Entry<String, Double>> results = SynProcess.processPatternLocalSpecify(test, synSetStr, targetWord, lp, settingPath, doRegex, usePPL);//	        ArrayList<Map.Entry<String, Double>> results = SynProcess.processPatternLocalSpecifyDice(test, synSetStr, targetWord, lp, settingPath, doRegex, usePPL, patternStat, emoStat);        	        ArrayList<Map.Entry<String, Double>> results = SynProcess.processPatternLocalSpecifyTFIDF(test, synSetStr, targetWord, lp, settingPath, doRegex, usePPL, patternStat, emoStat);        //	        ArrayList<synResult> orderedResults = PatternStats.getOrderedResults(results);	        //	        System.out.print("\nSuggested synonym (top " + amount + "): ");	        System.out.print("\nSuggested synonym (all) ");	        if( results.size() != 0) {				Iterator it = results.iterator();//				int current = 0;				int current = 1;				while (it.hasNext()) {					String[] entryString = it.next().toString().split("=");		//			System.out.print(entryString[0] + " ");					System.out.print(entryString[0]+"("+entryString[1]+")"+" ");					//					bw.write(entryString[0] + "\t" + (amount+1-current) + "\n");					bw.write(entryString[0] + "\t" + current + "\n");										current++;//					if( current == amount)//						break;				}				System.out.println();			}	        else {	        	bw.write("\n");	        	System.out.println(targetWord);	        }	        bw.write("-\t-"+number+"-\n");	        number++;	        bw.flush();			System.out.print("=====================================\n"); //			*/		} 		bw.close();//		bw3.close();    }        public static HashMap<String, String> getEmotionHash(String listPath) throws IOException {    	HashMap<String, String> hash = new HashMap<String, String>();    	BufferedReader br = new BufferedReader(new FileReader(listPath));    	String line;    	while( (line=br.readLine())!= null) {    		if(line.length()<1 || line.contains(" ")) continue;    		if( !hash.containsKey(line))    			hash.put(line, line);    	}//    	System.out.println("HashSize = " + hash.size());    	return hash;    }        public static void getAvailableSynList(String inputDir, String outFile) throws IOException, JWNLException {    	final File folder = new File(inputDir );    	HashMap<String, String> emotionHash = getEmotionHash("emoWords.txt");		ArrayList<String> allInputFileList = getInputTxtFileList(PatternStats.listFilesForFolder(folder));		Iterator<String> iterator = allInputFileList.iterator();		BufferedReader br;		BufferedWriter bw = new BufferedWriter(new FileWriter(outFile));		TreeMap<String, String> sorted = new TreeMap<String, String>();		while( iterator.hasNext()) {			String currentFile = iterator.next();			if( !currentFile.contains(".txt")) continue;						String emoClass = currentFile.replace(".txt", "");			emoClass = emoClass.replaceAll("user\\d+_\\d+_", "");			br = new BufferedReader(new FileReader(inputDir + currentFile));	        String test = "";			String line;			while ((line = br.readLine()) != null) {					test += (line + "\n");			}			br.close();	//	        System.out.println("Content of the input file:\n" + test );	        	        //extract the starred emotion word	        String targetWord = extractTargetWord(test);//	        System.out.println("Target Emotion Word is: " + targetWord + "\n");	        String targetWordPOS = findTargetWordPOS(test, targetWord);	        test = test.replace("*", "");	        	        //look up the word on wordnet affect, find synsets	//        WordNetAffectDic.initialize();	        String tempSynSetStr = getSynsetStr(targetWord, targetWordPOS);	        tempSynSetStr = mergeSynStr( tempSynSetStr, VocabularyDotCom.getSynonyms(targetWord));	        String synSetStr = (tempSynSetStr.contains(targetWord+" ")) ? tempSynSetStr: (targetWord + " " + tempSynSetStr);	        synSetStr = getDoableSyns(synSetStr, emotionHash);	        String listString = "@" + emoClass + "::" + targetWord + ":\n" + synSetStr.replaceAll("\\s+", "\n") + "===================================\n";//	        bw.write("@" + emoClass + "::" + targetWord + ":\n");//	        bw.write(synSetStr.replaceAll("\\s+", "\n"));//	        bw.write("===================================\n");//	        bw.flush();	        sorted.put(listString, listString);		}		Iterator<String> it = sorted.keySet().iterator();		while( it.hasNext()) {			String current = it.next();			bw.write(current);		}		bw.close();    }    public static String getDoableSyns(String inputSynStr, HashMap<String, String> hash) {    	String result = "";    	String[] tokens = inputSynStr.split(" ");    	for(int i=0; i<tokens.length; i++) {    		if( hash.containsKey(tokens[i]))    			result += (tokens[i] + " ");    	}    	return result;    }   //        public static String synsynString(String synSetStr) throws JWNLException {    	String[] synonymTokens = synSetStr.split(" ");    	TreeMap<String, String> tempHold = new TreeMap<String, String>();//    	ArrayList<String> tempHold = new ArrayList<String>();    	for(int i=0; i<synonymTokens.length; i++) {    		String tempSynSetStr = getSynsetStrAll(synonymTokens[i]);			tempSynSetStr = mergeSynStr( tempSynSetStr, VocabularyDotCom.getSynonyms(synonymTokens[i]));			String[] tokens = tempSynSetStr.split(" ");			for(int j=0; j<tokens.length; j++) {				if(tokens[j].length()<1) continue;				if( !tempHold.containsKey(tokens[j]))					tempHold.put(tokens[j], tokens[j]);			}    	}    	String resultString = tempHold.keySet().toString();    	resultString = resultString.replace("[", "");    	resultString = resultString.replace("]", "");    	resultString = resultString.replaceAll(", ", " ");    	return resultString;    }	public static String mergeSynStr(String synStr1, String synStr2) {		ArrayList<String> tokenList = new ArrayList<String>();		String result = "";		String[] token = synStr2.split(" ");		for(int i=0; i<token.length; i++) {			if( token[i].contains("_")) continue;				tokenList.add(token[i]);//				result += token[i] + " ";		}		String[] tokens = synStr1.split(" ");		for(int i=0; i<tokens.length; i++) {			if(tokenList.contains(tokens[i]));			else				tokenList.add(tokens[i]);//				result = result + " " + tokens[i];		}		for(int i=0; i<tokenList.size(); i++) {			if( i != tokenList.size()-1)				result +=  tokenList.get(i) + " ";			else				result += tokenList.get(i);		}		result = result.replaceAll("\\s+", " ");		return result;	}    public static IndexWord getIndexWord(String targetWord, String targetWordPOS) throws JWNLException {    	IndexWord w;    	if(targetWordPOS==null)    		return null;    	System.out.println(targetWordPOS);    	if( targetWordPOS.equals("ADJECTIVE"))    		w = WordNetHelper.getWord(POS.ADJECTIVE, targetWord);    	else if( targetWordPOS.equals("ADVERB"))    		w = WordNetHelper.getWord(POS.ADVERB, targetWord);    	else if( targetWordPOS.equals("NOUN"))    		w = WordNetHelper.getWord(POS.NOUN, targetWord);    	else if ( targetWordPOS.equals("VERB"))    		w = WordNetHelper.getWord(POS.VERB, targetWord);    	else    		w = null;    	return w;    }    public static String getSynsetStrAll(String targetWord) throws JWNLException {    	String[] pos = {"ADJECTIVE", "ADVERB", "NOUN", "VERB"};    	String result = "";    	if( targetWord.equals("depressed"))    		System.out.println();    	for(int i=0; i<pos.length; i++) {    		IndexWord w = getIndexWord(targetWord, pos[i]);    		if( w == null)    			w = getIndexWord(WordNetHelper.Stem(targetWord), pos[i]);    		if( w != null ) {    			ArrayList<Synset> a = WordNetHelper.getRelated(w,PointerType.SIMILAR_TO);    			if( a != null && !a.isEmpty() ) {    				Iterator<Synset> it = a.iterator();    				while( it.hasNext()) {    					Word[] words = it.next().getWords();    					for(int j=0; j<words.length; j++) {    						String thisWord = (words[i].getLemma().replaceAll("\\(\\w+\\)", "") + " ");    						if( !result.contains(thisWord) )    							result += thisWord;    					}    				}    			}    		}    	}    	return result;    }    public static String getSynsetStr(String targetWord, String targetWordPOS) throws JWNLException {    	IndexWord w = getIndexWord(targetWord, targetWordPOS);    	String result = "";    	if( w != null) {    		ArrayList<Synset> a = WordNetHelper.getRelated(w,PointerType.SIMILAR_TO);//    		a.addAll(WordNetHelper.getRelated(w,PointerType.HYPONYM));    		if (a != null && !a.isEmpty()) {    			Iterator<Synset> it = a.iterator();    			while( it.hasNext()) {    				Word[] words = it.next().getWords();    				for(int i=0; i<words.length; i++) {    					result += (words[i].getLemma().replaceAll("\\(\\w+\\)", "") + " ");    				}    			}//    			System.out.println("result= " + result);    		}    	}    	return result;    }    public static String findTargetWordPOS(String text, String targetWord) {    	MaxentTagger tagger = new MaxentTagger("tagger/english-bidirectional-distsim.tagger");    	    	String targetSentence = getTargetSentence(text);//      System.out.println("Target Sentence: " + targetSentence);    	String tagged = tagger.tagString(targetSentence);//    	System.out.println("Taged Target Sentence:\n" + tagged);    	String POS = "";//    	System.out.println("targetWord:\n" + targetWord);    	String[] tokens = tagged.split(" ");    	for(int i=0; i<tokens.length; i++) {    		if( tokens[i].contains(targetWord)) {    			POS = findPOS(tokens[i]);    			break;    		}    	}//    	System.out.println("POS:\n" + POS);    	return POS;    }    public static String findPOS(String inStr) {    	String[] tokens = inStr.split("_");    	return posLookUP(tokens[1]);    }    public static String posLookUP(String POSabbr) {    	String result = "";    	if( POSabbr.equals("JJ") || POSabbr.equals("JJR") || POSabbr.equals("JJS"))    		result = "ADJECTIVE";    	else if( POSabbr.equals("NN") || POSabbr.equals("NNP") || POSabbr.equals("NNPS") || POSabbr.equals("NNS"))    		result = "NOUN";    	else if( POSabbr.equals("RB") || POSabbr.equals("RBR") || POSabbr.equals("RBS"))    		result = "ADVERB";    	else if( POSabbr.equals("VB") || POSabbr.equals("VBD") || POSabbr.equals("VBG") || POSabbr.equals("VBN") || POSabbr.equals("VBP") || POSabbr.equals("VBZ"))    		result = "VERB";    	else    		result = null;    	return result;    }    public static void synsetProcess(String inputText, String synSetStr) {    	String [] syns = synSetStr.split(" ");    	// analyze each synonym's point and print out     	for(int i=0; i<syns.length; i++) {    		float point = synAnalysis(inputText, syns[i]);    		System.out.println(syns[i]+" ("+point+")");    	}    }    public static float synAnalysis(String inputText, String synonym) {    	String rawGloss = VocabularyDotCom.getGloss(synonym); //look up gloss on vocabulary.com    	if( rawGloss != null) { //make sure there's gloss    		//perform stemming for both texts    		String stemmedGloss = textStemmer( rawGloss);    		String stemmedInput = textStemmer( inputText);    		return getSimilarity(stemmedInput, stemmedGloss);    	}    	else	//in case of no gloss found    		return 1;    }    public static float getSimilarity(String text1, String text2) {    	int count = 0;    	float point = 0;    	HashMap text1hash = new HashMap();    	HashMap text2hash = new HashMap();    	String[] text2tokens = text2.split("\\b");    	for(int i=0; i<text2tokens.length; i++) {    		if( !pronounDetect(text2tokens[i]) && !articleDetect(text2tokens[i]) && !conjunctionDetect(text2tokens[i]))    			text2hash.put(text2tokens[i], text2tokens[i]);    	}    	String[] text1tokens = text1.split("\\b");    	for(int i=0; i<text1tokens.length; i++) {    		if( !pronounDetect(text1tokens[i]) && !articleDetect(text1tokens[i]) && !conjunctionDetect(text1tokens[i]))    			text1hash.put(text1tokens[i], text1tokens[i]);    	}    	    	for(Iterator iter = text1hash.keySet().iterator(); iter.hasNext(); ) {    		String str = (String)iter.next();    		if( text2hash.containsKey(str))    			count++;    	}    	//    	System.out.println(count + " " + text1hash.size());    	point = (float)count / text1hash.size();    	return point;    }    public static String extractTargetWord(String text) {    	String emotionWord = "";    	String[] tokens = text.split("\\b");    	for(int i=0; i < tokens.length; i++)    	{    		if(tokens[i].contains("*"))    			emotionWord = tokens[i+1];    	}    	return emotionWord;    }    public static String getTargetSentence(String text) {    	String resultSentence = "";    	BreakIterator bi = BreakIterator.getSentenceInstance();    	bi.setText(text);    	int index = 0;    	while( bi.next() != BreakIterator.DONE)    	{    		String sentence = text.substring(index, bi.current());    		if( sentence.contains("*"))    			resultSentence = sentence;    		index = bi.current();    	}    	resultSentence = resultSentence.replace("*", "");    	return resultSentence;    }    public static String textStemmer(String text) {    	String resultText = "";        BreakIterator bi = BreakIterator.getSentenceInstance(Locale.US);        bi.setText(text);        int index = 0;        //        System.out.println("Here is the stemmed paragraph: \n");        while( bi.next() != BreakIterator.DONE)        {        	String sentence = text.substring(index, bi.current());        	String[] tokens = sentence.split("\\b");            //String newSentence = "";                        for (int j=0; j < tokens.length; j++) {            	if( j==1 && pronounDetect(tokens[j]) )            		tokens[j] = tokens[j].toLowerCase();            	tokens[j] = WordNetHelper.Stem(tokens[j]);            	// Rebuild new sentence                resultText += tokens[j];            }            //resultText += " ";            //System.out.println(newSentence);        	index = bi.current();        }        return resultText;    }    public static boolean pronounDetect(String word) {    	String pronouns[] = {"I", "you", "he", "she", "it", "they", "we", "my", "our", "your", "their", "her", "his", "its"};    	for(int i=0; i<pronouns.length; i++)    	{    		if( word.equalsIgnoreCase(pronouns[i]))    			return true;    	}    	//System.out.println("\n" + word);    	return false;    }    public static boolean articleDetect(String word) {    	String articles[] = {"a", "an", "the"};    	for(int i=0; i<articles.length; i++)    		if(word.equalsIgnoreCase(articles[i]))    			return true;    	return false;    }    public static boolean conjunctionDetect(String word) {    	String conjs[] = {"and", "or", "but", "nor"};    	for(int i=0; i<conjs.length; i++)    		if(word.equalsIgnoreCase(conjs[i]))    			return true;    	return false;    }    public static String getSynonym(IndexWord w) throws JWNLException {        // Use the helper class to get an ArrayList of similar Synsets for an IndexWord        ArrayList a = WordNetHelper.getRelated(w,PointerType.SIMILAR_TO);        // As long as we have a non-empty ArrayList        if (a != null && !a.isEmpty()) {            System.out.println("Found a synonym for " + w.getLemma() + ".");            // Pick a random Synset            int rand = (int) (Math.random() * a.size());            Synset s = (Synset) a.get(rand);            // Pick a random Word from that Synset            Word[] words = s.getWords();            rand = (int) (Math.random() * words.length);            return words[rand].getLemma();        }        return null;    }    public static Double getWordSimilarity(IndexWord word1, IndexWord word2) throws JWNLException {    	RelationshipList list = RelationshipFinder.getInstance().findRelationships(word1.getSense(1), word2.getSense(1), PointerType.HYPERNYM);    	int distance = ((Relationship) list.get(0)).getDepth();    	Double wordSimilarity = 1/(double)distance;    	return wordSimilarity;    }	public static void demonstrateAsymmetricRelationshipOperation(IndexWord start, IndexWord end) throws JWNLException {		// Try to find a relationship between the first sense of <var>start</var> and the first sense of <var>end</var>		RelationshipList list = RelationshipFinder.getInstance().findRelationships(start.getSense(1), end.getSense(1), PointerType.HYPERNYM);		System.out.println("Hypernym relationship between \"" + start.getLemma() + "\" and \"" + end.getLemma() + "\":");		for (Iterator itr = list.iterator(); itr.hasNext();) {			((Relationship) itr.next()).getNodeList().print();			System.out.println();		}		System.out.println("List size = " + list.size());		int CPI = ((AsymmetricRelationship) list.get(0)).getCommonParentIndex();		System.out.println("Common Parent Index: " + ((AsymmetricRelationship) list.get(0)).getCommonParentIndex());		System.out.println("Common Parent : " + ((Relationship) list.get(0)).getNodeList().get(CPI));		System.out.println("Common Parent usage count: " + ((PointerTargetNode)((Relationship) list.get(0)).getNodeList().get(CPI)).getSynset().getWord(0).getUsageCount() );		System.out.println("Depth: " + ((Relationship) list.get(0)).getDepth());	}	public static void demonstrateListOperation(IndexWord word) throws JWNLException {		// Get all of the hypernyms (parents) of the first sense of <var>word</var>		PointerTargetNodeList hypernyms = PointerUtils.getInstance().getDirectHypernyms(word.getSense(1));		System.out.println("Direct hypernyms of \"" + word.getLemma() + "\":");		hypernyms.print();	}	public static TreeMap<String, Double> DiceBuildStat (String inputFile) throws IOException {		TreeMap<String,Double> results = new TreeMap<String,Double>();		BufferedReader br = new BufferedReader(new FileReader(inputFile));		String line;		while( (line = br.readLine())!= null) {			String[] tokens = line.split("\t");			String pattern = tokens[0];//			System.out.println(pattern);			double Value = Double.parseDouble(tokens[1]);			results.put(pattern, Value);		}		br.close();		return results;	}}